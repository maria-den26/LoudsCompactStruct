# ХАСД Практическая работа № 5
## Выполнили
- Денисова Мария
- Конончук Сергей
- Полухин Максим

## LOUDS (Level-Order Unary Degree Sequence)
 LOUDS - это компактная структура данных, предстовляющая корневое упорядоченное дерево, содержащее узлы произвольной степени.
 - Данная структура позволяет хранить информацию о структуре дерева в формате битовой строки длиной 2n + 1, где n - число узлов.
 - Битова строка формируется последовательностями единично-закодированных узлов, сортированных по уровням.
 - Для построения битовой строки в дерево добавляется дополнительный узел - искусственный корень. Он кодируется как '10'. Он имеет индекс -1.
 - Все настоящие узлы дерева индексируются начиная с 0 в порядке BFS(обход в ширину).
 - В соответствии с нумерацией узлов заполняется битовая строка: для узла определяется количество потомков, в битовую строку записываются единицы в соответствии с количеством потомков, последовательность единиц заканчивает нулем, операция повторяется для следующего узла.
 - Если узел является листом, он записывается просто как 0. 
   ```
   // Пример дерева:
   
           0
         / | \
        1  2  3
          / \
         4   5

   // Битова строка LOUDS: 10 1110 0 110 0 0 0
   ```
 - Навигация по дереву осуществляется с помощью опираций _RANK_ и _SELECT_.
 - _RANKx(i)_ возвращает количество бит, равных _x_, чьи индексы лежат на отрезке _[0; i]_. Так как _x_ — значение бита, то он может быть равен исключительно 0 или 1.
 - _SELECTx(j)_ возвращает индекс _j_-го бита, равного _x_. _j > 0_, то есть подсчет ведется от единицы. Кроме того, _j_ не может превышать суммарное количество битов в словаре, равных _x_.
 - _SELECT_ является обратной операцией для _RANK_.
 - Эффективность использования LOUDS напрямую зависит от эффективности реализации методов _RANK_ и _SELECT_. В нашей реализации происходит предрасчет таблиц для _RANK1_, _SELECT1_ и _SELECT0_, поэтому базовые операции (поиск родителя, первого потомка, последнего потомка) имеют сложность *O(1)*.

## Пример использования LOUDS
Так как LOUDS является деревом, данная структура может быть использована как префиксное дерево для поиска слов.

**Сравнительная таблица нашей реализации LOUDS Trie и простого Trie:**
| | **LOUDS Trie** | **Trie** |
|-|-------|------|
| *Сложность поиска* | O(m*log(k)), где m - длина слова, k - средняя степень узла | O(n), где n - длина слова |
| | **Поиск 10% слов от общего объема** | |
| Среднее время поиска (5000 слов)| 2 ms | 1 ms |
| Среднее время поиска (7500 слов)| 2 ms | 1 ms |
| Среднее время поиска (10000 слов)| 2 ms | 1 ms |
| Среднее время поиска (25000 слов)| 5 ms | 2 ms |
| Среднее время поиска (50000 слов)| 14 ms | 3 ms |
| Среднее время поиска (75000 слов)| 25 ms | 9 ms |
| Среднее время поиска (100000 слов)| 47 ms | 14 ms |
| | **Поиск 500 слов** | |
| Среднее время поиска (5000 слов)| 2 ms | 1 ms |
| Среднее время поиска (7500 слов)| 3 ms | 1 ms |
| Среднее время поиска (10000 слов)| 1 ms | 1 ms |
| Среднее время поиска (25000 слов)| 2 ms | 2 ms |
| Среднее время поиска (50000 слов)| 3 ms | 1 ms |
| Среднее время поиска (75000 слов)| 2 ms | 1 ms |
| Среднее время поиска (100000 слов)| 6 ms | 1 ms |
| | **Поиск 1000 слов** | |
| Среднее время поиска (5000 слов)| 2 ms | 1 ms |
| Среднее время поиска (7500 слов)| 3 ms | 1 ms |
| Среднее время поиска (10000 слов)| 2 ms | 1 ms |
| Среднее время поиска (25000 слов)| 2 ms | 1 ms |
| Среднее время поиска (50000 слов)| 9 ms | 2 ms |
| Среднее время поиска (75000 слов)| 11 ms | 2 ms |
| Среднее время поиска (100000 слов)| 12 ms | 2 ms |
| *Операции добавления/удаления узла* | Не поддерживаются без дополнительных структур данных, так как номера узлов становятся не действительны | Поддерживаются |

## Выводы
- По времени выполнения поиска в классическом Trie 
